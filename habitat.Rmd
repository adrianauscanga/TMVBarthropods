---
title: "Structure by habitat type"
output: html_notebook
---

Use the trees resulted from the GMYC analysis (in "otus_delimitation.Rmd"). First, get population names and habitat from sequences names. B corresponds to forest and Z to alpine grasslands. | Se usan los árboles que resultaron del análisis GMYC (explicado en "otus_delimitation.Rmd"). Primero, se obtienen los nombres de las poblaciones y el tipo de vegetación de los nombres de las secuencias. B corresponde a bosques, y Z a pastizal alpino.

```{r}
x<-CurcuTgmyc
nomtips<-substr((x$tr)$tip.label, 1,2)
nomtips #Population
samtips<-substr((x$tr)$tip.label, 3,3)
samtips #habitat
#Definir color por tipo de vegetación (samtips)
samtips<-as.factor(samtips)
levels(samtips)<-c("green", "blue")
samtips
```

Modify the plot function from splits (add a 2 so R don't get confused) | Se modifica la función de graficar del paquete splits (se agrega un 2 para que R no se confunda)
```{r}
plotCluster2 <- function(tr, lthresh, show.tip.label = FALSE, # tip labels to FALSE
show.node.label = FALSE, cex = 0.5) {
numnod <- tr$Nnode
numtip <- length(tr$tip.label)
cdat <- array(1, 2 * numnod)
ndat <- array("", numnod)
bt <- -branching.times(tr)
nest.nodes <- function(tr, x, p = 0) {
numtip <- length(tr$tip.label)
nods <- array(NA, 0)
desc <- as.integer(tr$edge[, 2][tr$edge[, 1] == x])
if (desc[1] > numtip) {
nods <- c(nods, desc[1], nest.nodes(tr, desc[1]))
}
if (desc[2] > numtip) {
nods <- c(nods, desc[2], nest.nodes(tr, desc[2]))
}
if (length(nods) > 0) {
return(nods)
}
else {
return(NULL)
}
}
threshold.group <- function(mrcas) {
parent <- tr$edge[, 1]
child <- tr$edge[, 2]
thresh.group <- list()
thresh.time <- c()
mrcas <- mrcas + numtip
k <- 1
while (TRUE) {
times <- bt[mrcas - numtip]
thresh1.time <- min(times)
thresh1.node <- mrcas[which.min(times)]
mrcas <- mrcas[-which.min(times)]
if (length(mrcas) == 0) {
thresh.time <- c(thresh.time, thresh1.time)
thresh.group[[k]] <- thresh1.node
break
}
member <- thresh1.node
del <- c()
for (i in 1:length(mrcas)) {
par.nod <- parent[child == mrcas[i]]
t.par <- bt[par.nod - numtip]
if (t.par < thresh1.time) {
member <- c(member, mrcas[i])
del <- c(del, i)
}
}
thresh.time <- c(thresh.time, thresh1.time)
thresh.group[[k]] <- member
k <- k + 1
if (length(del) != 0) {
mrcas <- mrcas[-del]
}
if (length(mrcas) == 0) {
break
}
}
return(thresh.group)
}
group <- threshold.group(lthresh)
colors <- rainbow(length(group))
k <- 1
for (g in group) {
n.col.type <- rep(0, numnod)
for (j in 1:length(g)) {
n.col.type[g[j] - numtip] <- 2
n.col.type[nest.nodes(tr, g[j]) - numtip] <- 1
}
cdat[match(tr$edge[, 1], which((n.col.type == 1) |
(n.col.type == 2)) + numtip) > 0] <-
colors[k]
k <- k + 1
}
plot(tr, edge.color = cdat, use.edge.length = 1, show.node.label =
show.node.label,
show.tip.label = show.tip.label, no.margin = FALSE,
cex = cex)
}
```

Plot the tree according to habitat type | Se grafica el árbol de acuerdo al habitat 
```{r}
plotCluster2(x$tree, x$MRCA[[which.max(x$likelihood)]])
tiplabels(text=nomtips, frame="none", adj=0, cex=0.5,
col=as.vector(samtips))
```

Repeat with other trees | Se repite con los demás árboles
